#!/usr/bin/env node

/**
 * Velite replacement - processes MDX files and generates content structure
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { createRequire } from 'module';

const require = createRequire(import.meta.url);
const matter = require('gray-matter');

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const DOCS_CONTENT_DIR = path.join(__dirname, '../docs/content');
const VELITE_DIR = path.join(__dirname, '../.velite');

// Ensure .velite directory exists
if (!fs.existsSync(VELITE_DIR)) {
  fs.mkdirSync(VELITE_DIR, { recursive: true });
}

/**
 * Extract table of contents from markdown
 * Converts to format expected by TableOfContents: { title: string; url: string; items: TocEntry[] }[]
 */
function extractTOC(content) {
  const flatToc = [];
  const headingRegex = /^(#{1,6})\s+(.+)$/gm;
  let match;

  while ((match = headingRegex.exec(content)) !== null) {
    const level = match[1].length;
    const title = match[2].trim();
    const id = title
      .toLowerCase()
      .replace(/[^\w\s-]/g, '')
      .replace(/\s+/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-+|-+$/g, '');

    flatToc.push({ id, title, level });
  }

  // Convert flat structure to nested structure expected by TableOfContents
  function buildNestedToc(items, startIndex = 0, currentLevel = 1) {
    const result = [];
    let i = startIndex;

    while (i < items.length) {
      const item = items[i];
      if (item.level < currentLevel) {
        // Back to a higher level, stop processing
        break;
      }
      if (item.level === currentLevel) {
        // Same level, add as sibling
        const tocEntry = {
          title: item.title,
          url: `#${item.id}`,
          items: [],
        };
        // Check for children
        const children = buildNestedToc(items, i + 1, currentLevel + 1);
        if (children.length > 0) {
          tocEntry.items = children;
          i += children.length + 1; // Skip processed children
        } else {
          i++;
        }
        result.push(tocEntry);
      } else {
        // Deeper level, should have been handled by recursion
        i++;
      }
    }

    return result;
  }

  return buildNestedToc(flatToc);
}

/**
 * Generate slug from file path
 */
function generateSlug(filePath, baseDir) {
  const relative = path.relative(baseDir, filePath);
  return relative
    .replace(/\.mdx$/, '')
    .replace(/\\/g, '/')
    .toLowerCase();
}

/**
 * Load all MDX files
 */
function loadAllMDXFiles() {
  const docs = [];

  if (!fs.existsSync(DOCS_CONTENT_DIR)) {
    console.warn(`Docs content directory not found: ${DOCS_CONTENT_DIR}`);
    return docs;
  }

  function walkDir(dir) {
    const entries = fs.readdirSync(dir, { withFileTypes: true });

    for (const entry of entries) {
      if (entry.name.startsWith('.') || entry.name === 'node_modules') {
        continue;
      }

      const fullPath = path.join(dir, entry.name);

      if (entry.isDirectory()) {
        walkDir(fullPath);
      } else if (entry.name.endsWith('.mdx')) {
        try {
          const fileContent = fs.readFileSync(fullPath, 'utf-8');
          const { data, content } = matter(fileContent);
          const slug = generateSlug(fullPath, DOCS_CONTENT_DIR);
          const toc = extractTOC(content);

          docs.push({
            slug,
            title: data.title || path.basename(fullPath, '.mdx'),
            description: data.description || '',
            category: data.category || 'reference',
            section: data.section,
            order: data.order || 999,
            content, // For now, store raw MDX content
            code: content, // Placeholder for compiled MDX
            toc: toc.length > 0 ? toc : undefined,
          });
        } catch (error) {
          console.error(`Error loading MDX file ${fullPath}:`, error);
        }
      }
    }
  }

  walkDir(DOCS_CONTENT_DIR);
  return docs.sort((a, b) => a.order - b.order);
}

// Generate content
console.log('Building content from MDX files...');
const docs = loadAllMDXFiles();

// Generate TypeScript content file
const contentFile = `// Auto-generated by velite-build script
export interface Doc {
  slug: string;
  title: string;
  description?: string;
  category: string;
  section?: string;
  order: number;
  content: string;
  code: string;
  toc?: Array<{ title: string; url: string; items: Array<any> }>;
}

export const docs: Doc[] = ${JSON.stringify(docs, null, 2)};
`;

fs.writeFileSync(path.join(VELITE_DIR, 'content.ts'), contentFile);
console.log(`âœ… Generated ${docs.length} documentation files`);

