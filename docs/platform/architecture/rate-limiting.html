<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rate Limiting Architecture</title>
    <meta name="description" content="Rate limiting implementation for BigCommerce API calls">
    <!-- frontmatter
title: "Rate Limiting Architecture"
description: "Rate limiting implementation for BigCommerce API calls"
category: "platform"
order: 1
-->
</head>
<body>

<h1>Rate Limiting Architecture</h1>

<p>The migration system implements intelligent rate limiting to respect BigCommerce API limits and ensure reliable operation.</p>

<h2>Overview</h2>

<p>BigCommerce API has strict rate limits:</p>

<ul>
<li><strong>150 requests per 30 seconds</strong> (sliding window)</li>
<li>Rate limit headers in responses</li>
<li>Automatic queuing when limits are reached</li>
</ul>

<h2>Implementation</h2>

<p>The rate limiter uses <code>Bottleneck</code> library for efficient request queuing and throttling.</p>

<h3>Configuration</h3>

<pre><code class="language-typescript">// src/lib/rate-limiter.ts
import Bottleneck from 'bottleneck';

const BC_REQUESTS_PER_WINDOW = 140; // Conservative limit (leave headroom)
const BC_WINDOW_MS = 30000; // 30 seconds

export const bcRateLimiter = new Bottleneck({
  reservoir: BC_REQUESTS_PER_WINDOW,
  reservoirRefreshAmount: BC_REQUESTS_PER_WINDOW,
  reservoirRefreshInterval: BC_WINDOW_MS,
  maxConcurrent: 10, // Max concurrent requests
  minTime: 100, // Minimum time between requests (ms)
});
</code></pre>

<h3>Key Features</h3>

<ul>
<li><strong>Reservoir System:</strong> Tracks available requests in a sliding window</li>
<li><strong>Automatic Queuing:</strong> Queues requests when limit is reached</li>
<li><strong>Concurrency Control:</strong> Limits concurrent requests to prevent overload</li>
<li><strong>Minimum Time:</strong> Enforces minimum delay between requests</li>
</ul>

<h2>Usage</h2>

<h3>Wrapping Functions</h3>

<pre><code class="language-typescript">import { withRateLimit } from '@/lib/rate-limiter';

// Wrap an async function with rate limiting
const rateLimitedFunction = withRateLimit(async (productId: number) => {
  return await bcClient.getProduct(productId);
});

// Use with priority
const highPriorityFunction = withRateLimit(
  async () => { /* ... */ },
  10 // Higher priority (1-10)
);
</code></pre>

<h3>Monitoring</h3>

<pre><code class="language-typescript">import { getRateLimiterStats } from '@/lib/rate-limiter';

const stats = getRateLimiterStats();
console.log(`Running: ${stats.running}, Queued: ${stats.queued}`);
</code></pre>

<h2>Rate Limit Headers</h2>

<p>The system monitors BigCommerce rate limit headers:</p>

<ul>
<li><code>X-Rate-Limit-Requests-Left</code> - Remaining requests</li>
<li><code>X-Rate-Limit-Time-Reset-Ms</code> - Time until reset (milliseconds)</li>
</ul>

<pre><code class="language-typescript">export function updateRateLimitFromHeaders(headers: Record&lt;string, string&gt;): void {
  const requestsLeft = parseInt(headers['x-rate-limit-requests-left'] || '0', 10);
  const timeResetMs = parseInt(headers['x-rate-limit-time-reset-ms'] || '0', 10);

  if (requestsLeft > 0 && requestsLeft &lt; 20) {
    logger.warn({ requestsLeft, timeResetMs }, 'Approaching rate limit');
  }
}
</code></pre>

<h2>Best Practices</h2>

<ul>
<li>Use conservative limits (140/150) to leave headroom</li>
<li>Monitor rate limit headers from responses</li>
<li>Implement priority queuing for critical operations</li>
<li>Log warnings when approaching limits</li>
<li>Use caching to reduce API calls</li>
</ul>

<h2>Related Documentation</h2>

<ul>
<li><a href="error-handling.html">Error Handling Architecture</a></li>
<li><a href="caching.html">Caching Architecture</a></li>
<li><a href="api-clients.html">API Clients Architecture</a></li>
</ul>

</body>
</html>

