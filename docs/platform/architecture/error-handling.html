<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Error Handling Architecture</title>
    <meta name="description" content="Error handling patterns and retry logic for migration operations">
    <!-- frontmatter
title: "Error Handling Architecture"
description: "Error handling patterns and retry logic for migration operations"
category: "platform"
order: 2
-->
</head>
<body>

<h1>Error Handling Architecture</h1>

<p>The migration system implements comprehensive error handling with automatic retry logic for transient failures.</p>

<h2>Error Classes</h2>

<h3>MigrationError</h3>

<p>Base class for all migration errors with structured information:</p>

<pre><code class="language-typescript">export class MigrationError extends Error {
  public readonly code: string;
  public readonly retriable: boolean;
  public readonly context?: Record&lt;string, unknown&gt;;
  public readonly timestamp: string;
}
</code></pre>

<h3>Specialized Error Types</h3>

<ul>
<li><strong>RateLimitError</strong> - Rate limit exceeded (retriable)</li>
<li><strong>ApiError</strong> - API request failures</li>
<li><strong>ValidationError</strong> - Data validation failures (not retriable)</li>
<li><strong>DuplicateError</strong> - Duplicate item errors (not retriable)</li>
<li><strong>ConfigurationError</strong> - Configuration issues (not retriable)</li>
<li><strong>ConnectionError</strong> - Network/connection errors (retriable)</li>
</ul>

<h2>Retry Logic</h2>

<h3>Retriable Errors</h3>

<p>Errors that are automatically retried:</p>

<ul>
<li>429 Too Many Requests (rate limited)</li>
<li>5xx Server Errors</li>
<li>Network timeouts (ECONNRESET, ETIMEDOUT, ECONNABORTED)</li>
<li>Connection errors</li>
</ul>

<h3>Non-Retriable Errors</h3>

<p>Errors that are not retried:</p>

<ul>
<li>4xx Client Errors (except 429)</li>
<li>Validation errors</li>
<li>Configuration errors</li>
<li>Duplicate item errors</li>
</ul>

<h2>Retry Implementation</h2>

<h3>Exponential Backoff</h3>

<pre><code class="language-typescript">import { withRetry } from '@/lib/retry';

const result = await withRetry(
  async () => {
    return await api.getProduct(productId);
  },
  {
    retries: 3,
    minTimeout: 1000, // 1 second
    maxTimeout: 30000, // 30 seconds
    factor: 2, // Double delay each retry
    randomize: true, // Add jitter
  }
);
</code></pre>

<h3>Retry-After Header</h3>

<p>The system respects <code>Retry-After</code> headers from rate limit responses:</p>

<pre><code class="language-typescript">export function getRetryAfterMs(error: unknown): number | null {
  const axiosError = error as AxiosError;
  
  // Check Retry-After header
  const retryAfter = axiosError.response?.headers?.['retry-after'];
  if (retryAfter) {
    return parseInt(retryAfter, 10) * 1000;
  }
  
  // Check BC-specific header
  const resetMs = axiosError.response?.headers?.['x-rate-limit-time-reset-ms'];
  if (resetMs) {
    return parseInt(resetMs, 10);
  }
  
  return null;
}
</code></pre>

<h2>Error Wrapping</h2>

<pre><code class="language-typescript">import { wrapError, ApiError } from '@/lib/errors';

try {
  await api.getProduct(productId);
} catch (error) {
  // Wrap any error as MigrationError
  const migrationError = wrapError(error, { productId });
  
  // Or convert axios errors specifically
  if (isAxiosError(error)) {
    const apiError = ApiError.fromAxiosError(error, { productId });
  }
}
</code></pre>

<h2>Best Practices</h2>

<ul>
<li>Always wrap errors with context</li>
<li>Use retry logic for transient failures</li>
<li>Respect Retry-After headers</li>
<li>Log errors with sufficient context</li>
<li>Distinguish retriable from non-retriable errors</li>
</ul>

<h2>Related Documentation</h2>

<ul>
<li><a href="rate-limiting.html">Rate Limiting Architecture</a></li>
<li><a href="logging.html">Logging Architecture</a></li>
</ul>

</body>
</html>

