/**
 * Validation Report Generator
 * Generates reports in JSON and Markdown formats
 */

import * as fs from 'fs';
import * as path from 'path';
import type { ValidationResult, ValidationCheck, ValidationStatus } from './data-validator.js';
import { logger } from '../lib/logger.js';

const STATUS_EMOJI: Record<ValidationStatus, string> = {
  pass: 'PASS',
  fail: 'FAIL',
  warning: 'WARN',
  skipped: 'SKIP',
};

const STATUS_SYMBOLS: Record<ValidationStatus, string> = {
  pass: '[PASS]',
  fail: '[FAIL]',
  warning: '[WARN]',
  skipped: '[SKIP]',
};

export interface ReportOptions {
  outputDir?: string;
  includeDetails?: boolean;
}

const DEFAULT_OPTIONS: ReportOptions = {
  outputDir: './reports',
  includeDetails: true,
};

export class ValidationReportGenerator {
  private options: ReportOptions;

  constructor(options: ReportOptions = {}) {
    this.options = { ...DEFAULT_OPTIONS, ...options };
  }

  /**
   * Generate both JSON and Markdown reports
   */
  async generateReports(result: ValidationResult): Promise<{ json: string; markdown: string }> {
    // Ensure output directory exists
    const outputDir = this.options.outputDir!;
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
    const jsonPath = path.join(outputDir, `validation-${timestamp}.json`);
    const markdownPath = path.join(outputDir, `validation-${timestamp}.md`);

    // Generate JSON report
    const jsonContent = JSON.stringify(result, null, 2);
    fs.writeFileSync(jsonPath, jsonContent, 'utf-8');

    // Generate Markdown report
    const markdownContent = this.generateMarkdown(result);
    fs.writeFileSync(markdownPath, markdownContent, 'utf-8');

    logger.info({ jsonPath, markdownPath }, 'Validation reports generated');

    return { json: jsonPath, markdown: markdownPath };
  }

  /**
   * Generate Markdown report content
   */
  generateMarkdown(result: ValidationResult): string {
    const lines: string[] = [];

    // Header
    lines.push('# Migration Validation Report');
    lines.push('');
    lines.push(`**Generated:** ${result.timestamp}`);
    lines.push(`**Duration:** ${result.duration}ms`);
    lines.push(`**Overall Status:** ${STATUS_SYMBOLS[result.overallStatus]} ${result.overallStatus.toUpperCase()}`);
    lines.push('');

    // Summary
    lines.push('## Summary');
    lines.push('');
    lines.push('| Metric | Count |');
    lines.push('|--------|-------|');
    lines.push(`| Total Checks | ${result.summary.total} |`);
    lines.push(`| Passed | ${result.summary.passed} |`);
    lines.push(`| Failed | ${result.summary.failed} |`);
    lines.push(`| Warnings | ${result.summary.warnings} |`);
    lines.push(`| Skipped | ${result.summary.skipped} |`);
    lines.push('');

    // Detailed Results
    lines.push('## Detailed Results');
    lines.push('');

    for (const check of result.checks) {
      lines.push(`### ${STATUS_SYMBOLS[check.status]} ${check.name}`);
      lines.push('');
      lines.push(`**Description:** ${check.description}`);
      lines.push('');
      lines.push(`**Status:** ${check.status.toUpperCase()}`);
      lines.push('');
      lines.push(`**Message:** ${check.message}`);
      lines.push('');

      if (this.options.includeDetails && check.details) {
        lines.push('**Details:**');
        lines.push('');
        lines.push('```json');
        lines.push(JSON.stringify(check.details, null, 2));
        lines.push('```');
        lines.push('');
      }

      lines.push('---');
      lines.push('');
    }

    // Recommendations
    lines.push('## Recommendations');
    lines.push('');

    const failedChecks = result.checks.filter(c => c.status === 'fail');
    const warningChecks = result.checks.filter(c => c.status === 'warning');

    if (failedChecks.length > 0) {
      lines.push('### Critical Issues');
      lines.push('');
      for (const check of failedChecks) {
        lines.push(`- **${check.name}:** ${this.getRecommendation(check)}`);
      }
      lines.push('');
    }

    if (warningChecks.length > 0) {
      lines.push('### Warnings');
      lines.push('');
      for (const check of warningChecks) {
        lines.push(`- **${check.name}:** ${this.getRecommendation(check)}`);
      }
      lines.push('');
    }

    if (result.overallStatus === 'pass') {
      lines.push('All validation checks passed. The migration appears to be complete.');
      lines.push('');
    }

    // Footer
    lines.push('---');
    lines.push('');
    lines.push('*Report generated by BC Migration Tool*');

    return lines.join('\n');
  }

  /**
   * Get recommendation text for a check
   */
  private getRecommendation(check: ValidationCheck): string {
    switch (check.name) {
      case 'Product Count':
        return 'Re-run product migration or check logs for failed items. Some products may have been skipped due to validation errors.';
      case 'Category Count':
        return 'Verify category hierarchy. Some categories may have failed due to naming conflicts or invalid parent references.';
      case 'Customer Count':
        return 'Check for customers with missing email addresses. These are skipped during migration.';
      case 'Price Validation':
        return 'Review the listed price mismatches. Prices may differ due to currency conversion or tax settings.';
      case 'Image Accessibility':
        return 'Check if the source image URLs are still accessible. Images may need to be re-uploaded or URLs updated.';
      default:
        return 'Review the check details and address any discrepancies.';
    }
  }

  /**
   * Print a formatted summary to console
   */
  printSummary(result: ValidationResult): void {
    console.log('\n╔════════════════════════════════════════════════════╗');
    console.log('║           MIGRATION VALIDATION REPORT              ║');
    console.log('╠════════════════════════════════════════════════════╣');

    for (const check of result.checks) {
      const status = STATUS_SYMBOLS[check.status];
      const name = check.name.padEnd(20);
      console.log(`║  ${status} ${name}                    ║`);
    }

    console.log('╠════════════════════════════════════════════════════╣');
    console.log(`║  OVERALL: ${STATUS_SYMBOLS[result.overallStatus]} ${result.overallStatus.toUpperCase().padEnd(36)}║`);
    console.log('╚════════════════════════════════════════════════════╝\n');
  }
}
