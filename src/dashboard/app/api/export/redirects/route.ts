import { NextRequest, NextResponse } from 'next/server';
import { createWCClient } from '@/lib/wc-client';

/**
 * 301 Redirects Export
 * Generates redirect rules for WC URLs to BC URLs
 * Outputs: CSV, .htaccess, and nginx format
 */

interface WCProduct {
  id: number;
  name: string;
  slug: string;
  permalink: string;
  sku: string;
}

interface WCCategory {
  id: number;
  name: string;
  slug: string;
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { url, consumerKey, consumerSecret, bcStoreUrl } = body;

    if (!url || !consumerKey || !consumerSecret) {
      return NextResponse.json(
        { success: false, error: 'Missing credentials' },
        { status: 400 }
      );
    }

    const wcClient = await createWCClient(url, consumerKey, consumerSecret);
    const targetBase = bcStoreUrl || '[YOUR-BC-STORE-URL]';

    // Fetch products
    const products: WCProduct[] = [];
    let page = 1;
    let hasMore = true;

    while (hasMore) {
      const response = await wcClient.get('products', {
        per_page: 100,
        page,
        status: 'publish',
      });

      if (response.data.length === 0) {
        hasMore = false;
      } else {
        products.push(...response.data);
        page++;
      }

      if (page > 50) break;
    }

    // Fetch categories
    const categoryResponse = await wcClient.get('products/categories', { per_page: 100 });
    const categories: WCCategory[] = categoryResponse.data;

    // Build redirect rules
    const redirects: Array<{ from: string; to: string; type: string }> = [];

    // Product redirects
    for (const product of products) {
      const wcPath = extractPath(product.permalink);
      // BC typically uses /product-name/ or /[sku]/
      const bcPath = product.sku
        ? `/${product.sku.toLowerCase().replace(/[^a-z0-9]/g, '-')}/`
        : `/${product.slug}/`;

      redirects.push({
        from: wcPath,
        to: `${targetBase}${bcPath}`,
        type: 'product',
      });
    }

    // Category redirects
    for (const category of categories) {
      // WC default: /product-category/[slug]/
      const wcPath = `/product-category/${category.slug}/`;
      // BC default: /[category-name]/
      const bcPath = `/${category.slug}/`;

      redirects.push({
        from: wcPath,
        to: `${targetBase}${bcPath}`,
        type: 'category',
      });
    }

    // Cart/Checkout redirects
    redirects.push(
      { from: '/cart/', to: `${targetBase}/cart.php`, type: 'system' },
      { from: '/checkout/', to: `${targetBase}/checkout`, type: 'system' },
      { from: '/my-account/', to: `${targetBase}/account.php`, type: 'system' },
      { from: '/shop/', to: `${targetBase}/`, type: 'system' },
    );

    // Generate different formats
    const csvContent = generateCSV(redirects);
    const htaccessContent = generateHtaccess(redirects);
    const nginxContent = generateNginx(redirects);

    return NextResponse.json({
      success: true,
      data: {
        redirects,
        formats: {
          csv: csvContent,
          htaccess: htaccessContent,
          nginx: nginxContent,
        },
        counts: {
          total: redirects.length,
          products: redirects.filter(r => r.type === 'product').length,
          categories: redirects.filter(r => r.type === 'category').length,
          system: redirects.filter(r => r.type === 'system').length,
        },
      },
    });

  } catch (error) {
    console.error('Export error:', error);
    return NextResponse.json(
      { success: false, error: error instanceof Error ? error.message : 'Export failed' },
      { status: 500 }
    );
  }
}

function extractPath(fullUrl: string): string {
  try {
    const url = new URL(fullUrl);
    return url.pathname;
  } catch {
    return fullUrl;
  }
}

function generateCSV(redirects: Array<{ from: string; to: string; type: string }>): string {
  const rows = [
    ['Old URL', 'New URL', 'Type'],
    ...redirects.map(r => [r.from, r.to, r.type]),
  ];

  return rows.map(row =>
    row.map(cell => {
      if (cell.includes(',') || cell.includes('"')) {
        return `"${cell.replace(/"/g, '""')}"`;
      }
      return cell;
    }).join(',')
  ).join('\n');
}

function generateHtaccess(redirects: Array<{ from: string; to: string }>): string {
  const lines = [
    '# 301 Redirects for WooCommerce to BigCommerce Migration',
    '# Generated by BC Migration Tool',
    '# Add this to your .htaccess file',
    '',
    'RewriteEngine On',
    '',
  ];

  for (const redirect of redirects) {
    // Escape special regex characters in the path
    const escapedFrom = redirect.from.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    lines.push(`RewriteRule ^${escapedFrom.replace(/^\//, '')}$ ${redirect.to} [R=301,L]`);
  }

  return lines.join('\n');
}

function generateNginx(redirects: Array<{ from: string; to: string }>): string {
  const lines = [
    '# 301 Redirects for WooCommerce to BigCommerce Migration',
    '# Generated by BC Migration Tool',
    '# Add this to your nginx config',
    '',
  ];

  for (const redirect of redirects) {
    lines.push(`rewrite ^${redirect.from}$ ${redirect.to} permanent;`);
  }

  return lines.join('\n');
}
